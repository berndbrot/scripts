#!/bin/bash
#
# cwhere
#
# find which C header file defines the requested macro/identifier
#
# Would normally do this in Perl, but doing it in pure bash for
# something different.
#
# Mikel Ward <mikel@mikelward.com>
#
# TODO move cleanup trap inside print_definitions()

name=cwhere

trap cleanup EXIT

# remove any temporary files, etc.
# Usage: cleanup
cleanup()
{
    test -f "$sourcefile" && rm "$sourcefile"
    test -f "$processedfile" && rm "$processedfile"
}

# Print the definition of <identifier> and which header file it appears in
# Usage: print_definitions <identifier> <header>...
# Example: print_definitions O_WRONLY sys/types.h sys/stat.h fcntl.h
print_definitions()
{
    local identifier="$1"
    shift
    local headers="$@"

    sourcefile=$(mktemp)
    if test $? -ne 0; then
        echo "Error: Cannot create source file" 1>&2
        exit 1
    fi
    for header in $headers; do
        echo "#include <$header>" >> "$sourcefile"
    done
    processedfile=$(mktemp)
    if test $? -ne 0; then
        echo "Error: Cannot create cpp output file" 1>&2
        exit 1
    fi
    cpp -dD "$sourcefile" > "$processedfile"
    if test $? -ne 0; then
        cat "$sourcefile"
        echo "Error: Cannot run cpp" 1>&2
        exit 1
    fi
    file=''
    while read -r line; do
        # this is evil, just doing it to learn something new
        # put the pattern in a variable to avoid bash treating pattern as a string :-(
        filenamepattern='^# [0-9]+ "([^"]*)"'
        identifierpattern='(^|#define|typedef)[[:space:]]*'"$identifier"'([[:space:]]|$)'
        if [[ $line =~ $filenamepattern ]]; then
            file=${BASH_REMATCH[1]}
        elif [[ $line =~ $identifierpattern ]]; then
            echo "$file: $line"
        fi
    done < "$processedfile"
}

# print a message saying how to run this program
usage()
{
    cat <<EOF 1>&2
Usage: $name IDENTIFIER HEADER [HEADER...]
Example:
    $name O_RDONLY sys/stat.h sys/types.h fcntl.h
    $name 'struct sockaddr(|in) sys/types.h sys/socket.h netinet/in.h
EOF
}

main()
{
    if test $# -lt 2; then
        usage
        exit 2
    fi

    print_definitions "$@"
}

# only run the main script if it was executed
# allows sourcing of the script to get function definitions
# works out of the box in bash and ksh
# zsh requires unsetopt functionargzero in ~/.zshenv
case "$0" in *$name)
    main "$@"
    ;;
esac

