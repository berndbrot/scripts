#!/bin/bash
#
# cwhere2
#
# find which C header file defines the requested macro/identifier
#
# Would normally do this in Perl, but doing it in pure bash for
# something different.
#
# Mikel Ward <mikel@mikelward.com>
#
# TODO move cleanup trap inside print_definitions()

name=cwhere2

trap cleanup EXIT

# remove any temporary files, etc.
# Usage: cleanup
cleanup()
{
    test -f "$sourcefile" && rm "$sourcefile"
    test -f "$processedfile" && rm "$processedfile"
}

# break <string> into words by splitting on delimiter <delim>
# Usage: split <delim> <string>
# Example: split , "foo,bar,baz"
split()
{
    if test $# -ne 2; then
        echo "Usage: split <delim> <string>" 1>&2
        return 1
    fi

    delim="$1"
    shift
    local IFS="$delim"
    local word
    for word in $1; do
        echo "$word"
    done
}

# Print the definition of <identifier> and which header file it appears in
# Usage: print_definitions <identifier> <header>...
# Example: print_definitions O_WRONLY sys/types.h sys/stat.h fcntl.h
print_definitions()
{
    sourcefile=$(mktemp)
    if test $? -ne 0; then
        echo "Error: Cannot create source file" 1>&2
        exit 1
    fi
    for header in $headers; do
        echo "#include <$header>" >> "$sourcefile"
    done
    processedfile=$(mktemp)
    if test $? -ne 0; then
        echo "Error: Cannot create cpp output file" 1>&2
        exit 1
    fi
    cpp -dD "$sourcefile" > "$processedfile"
    if test $? -ne 0; then
        cat "$sourcefile"
        echo "Error: Cannot run cpp" 1>&2
        exit 1
    fi
    file=''
    while read -r line; do
        # this is evil, just doing it to learn something new
        # put the pattern in a variable to avoid bash treating pattern as a string :-(
        filenamepattern='^# [0-9]+ "([^"]*)"'
        identifierpattern='(^|#define|typedef)[[:space:]]*'"$identifier"'([[:space:]]|$)'
        if [[ $line =~ $filenamepattern ]]; then
            file=${BASH_REMATCH[1]}
        elif [[ $line =~ $identifierpattern ]]; then
            echo "$file: $line"
        fi
    done < "$processedfile"
}

# print a message saying how to run this program
usage()
{
    cat <<EOF 1>&2
Usage: $name [-h HEADER[,HEADER...]] IDENTIFIER[|IDENTIFIER...]
Options:
    -h HEADER      Include HEADER, e.g. sys/types.h
Example:
    $name -h sys/types.h,sys/stat.h,fcntl.h O_RDONLY 
EOF
}

main()
{
    headers=''
    while getopts ":h:" option; do
        case $option in
        h)
            # e.g. -h HEADER1,HEADER2,HEADER3...
            headers="$(split , "$OPTARG")"
            ;;
        '?')
            echo "Error: Invalid option -$OPTARG" 1>&2
            usage
            exit 2
            ;;
        ':')
            echo "Error: Missing argument to -$OPTARG" 1>&2
            exit 2
            ;;
        *)
            echo "Error: Program does not support -$option yet" 1>&2
            exit 2
            ;;
        esac
    done
    shift $((OPTIND - 1))

    if test $# -ne 1; then
        usage
        exit 2
    fi

    identifier="$1"

    print_definitions "$identifier" $headers
}

# only run the main script if it was executed
# allows sourcing of the script to get function definitions
# works out of the box in bash and ksh
# zsh requires unsetopt functionargzero in ~/.zshenv
case "$0" in *$name)
    main "$@"
    ;;
esac

